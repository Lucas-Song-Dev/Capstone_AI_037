import pandas as pd

def excel_column_to_index(col_label):
    """Converts Excel column label (e.g., 'A', 'Z', 'ML') to 0-based index."""
    index = 0
    for char in col_label.upper():
        index = index * 26 + (ord(char) - ord('A') + 1)
    return index - 1

def trim_hwinfo_csv(input_path, output_path, keep_cols=None, keep_rows=None):
    """
    Docstring for trim_hwinfo_csv
    
    :param input_path: Relative path from script to HWiNFO logging file generated by run_mlc_and_log.py
    :param output_path: Relative path from script to save trimmed HWiNFO logging file
    :param keep_cols: A list of column ranges to keep, separated by hyphen (inclusive). E.g., ['C-H', 'J-Z'] keeps columns C to H and J to Z.
    :param keep_rows: A list of row ranges to keep, separated by hyphen (inclusive). E.g., ['0-100', '200-300'] keeps rows 0 to 100 and 200 to 300.
    """
    print(f"[*] Loading {input_path}...")
    
    try:
        df = pd.read_csv(input_path, encoding='latin-1', low_memory=False)
    except Exception as e:
        print(f"Error reading CSV: {e}")
        return
    print("Successfully loaded {} with {} columns and {} rows.".format(input_path, len(df.columns), len(df)))

    df_trimmed = df.copy()

    # optionally drop cols
    if keep_cols:
        cols_to_drop = []

        # keep_cols is a list of ranges (e.g. [A-C, J-Z]), isolate the columns to drop

        for i, interval in enumerate(keep_cols):
            start_col, end_col = interval.split('-')

            # cut from beginning to the first start_col
            if (i == 0 and start_col != 'A'):
                cut_end_idx = excel_column_to_index(start_col) - 1
                cols_to_drop.extend(df.columns[0 : cut_end_idx + 1])

            # get the first column to cut (end_col + 1)
            cut_start_idx = excel_column_to_index(end_col) + 1
            if (i != len(keep_cols) - 1):
                # if not the last interval, cut until the start of the next interval
                next_start_col = keep_cols[i + 1].split('-')[0]
                cut_end_idx = excel_column_to_index(next_start_col) - 1
            else:
                # if last interval, cut until the end
                cut_end_idx = len(df.columns) - 1

            cols_to_drop.extend(df.columns[cut_start_idx : cut_end_idx + 1])
            
        print("cols to drop:", cols_to_drop)

        # 3. Drop cols
        df_trimmed = df.drop(columns=cols_to_drop)

    # 4. Optionally trim rows
    if keep_rows:
        rows_to_drop = []
        # for some reason the header row is not read into df, so index 2 in excel corresponds to index 0
        
        keep_rows_0_indexed = list(map(lambda x: f"{max(int(x.split('-')[0]) - 2, 0)}-{max(int(x.split('-')[1]) - 2, 0)}", keep_rows)) 
        print("keep_rows_0_indexed:", keep_rows_0_indexed)
        keep_rows = keep_rows_0_indexed

        for i, interval in enumerate(keep_rows):
            print("Processing row interval {} out of {} total".format(interval, len(keep_rows)))
            start_row, end_row = map(int, interval.split('-'))

            if (i == 0 and start_row != 0):
                cut_end_idx = start_row - 1
                rows_to_drop.extend(range(0, cut_end_idx + 1))

            cut_start_idx = 0 if (end_row == 0) else end_row + 1
            if (i != len(keep_rows) - 1):
                # if not the last interval, cut until the start of the next interval
                next_start_row = int(keep_rows[i + 1].split('-')[0])
                cut_end_idx = next_start_row - 1
            else:                
                # if last interval, cut until the end
                cut_end_idx = len(df_trimmed) - 1
                print("Last interval, setting cut_end_idx to:", cut_end_idx)
            rows_to_drop.extend(range(cut_start_idx, cut_end_idx + 1))

        print("rows to drop:", rows_to_drop)
        df_trimmed = df_trimmed.drop(index=rows_to_drop)

    df_trimmed.to_csv(output_path, index=False)
    
    print(f"[+] Success! Trimmed file saved to: {output_path}")
    print(f"    Remaining columns: {len(df_trimmed.columns)}")
    print(f"    Remaining rows: {len(df_trimmed)}")

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Trim HWiNFO CSV logs by removing specified columns.")
    parser.add_argument("-i", type=str,
                       help="Input path to HWiNFO CSV file with empirical power measurements")
    parser.add_argument("-o", type=str,
                       help="Output path to save the trimmed HWiNFO CSV file")
    parser.add_argument("--keep-cols", nargs='+', type=str,
                        help="List of column ranges to keep (alpha-indexed), separated by hyphen (inclusive). E.g., C-H J-Z keeps columns C to H and J to Z. " \
                        "If empty, all columns will be kept.")
    parser.add_argument("--keep-rows", nargs='+', type=str,
                        help="List of row ranges to keep (1-indexed), separated by hyphen (inclusive). E.g., 1-100 200-300 keeps rows 1 to 100 and 200 to 300." \
                        " If empty, all rows will be kept.")

    args = parser.parse_args()

    if (not args.i) or (not args.o):
        print("Error: Please provide -i (input path) and -o (output path) arguments.")
        print("E.g. for trimming to keep DRAM relevant columns, run with --keep-cols B-B MF-NA")
        exit(1)
    
    trim_hwinfo_csv(
        input_path=args.i, 
        output_path=args.o,
        keep_cols=args.keep_cols if args.keep_cols else "B-B MF-NA",
        keep_rows=args.keep_rows
    )
    